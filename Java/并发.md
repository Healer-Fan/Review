## 同步互斥
### synchronized [参考](http://www.cnblogs.com/dolphin0520/p/3923737.html)
如果对临界资源加上互斥锁，当一个线程在访问该临界资源时，其他线程便只能等待。
在Java中，每一个对象都拥有一个**锁标记（monitor）**，也称为监视器，多线程同时访问某个对象时，线程只有获取了该对象的锁才能访问。
在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法或方法块，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。
#### synchronized方法
```java
public class Main {
    public static void main(String[] args) {
        final InsertData insertData = new InsertData();

        new Thread(() -> insertData.insert(Thread.currentThread())).start();

        new Thread(() -> insertData.insert(Thread.currentThread())).start();
    }
}

class InsertData {
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();
    
    public void insert(Thread thread) {
        for (int i = 0; i < 20; i++) {
            System.out.println(thread.getName() + "在插入数据" + i);
            arrayList.add(i);
        }
    }
}
```
结果：
```
Thread-0在插入数据0
Thread-0在插入数据1
Thread-0在插入数据2
Thread-0在插入数据3
Thread-1在插入数据0
Thread-0在插入数据4
Thread-1在插入数据1
Thread-0在插入数据5
Thread-1在插入数据2
...
```
说明两个线程在同时执行insert方法。

在insert方法前面加上关键字synchronized
```java
public class InsertData {

    private ArrayList<Integer> arrayList = new ArrayList<Integer>();

    public synchronized void insert(Thread thread) {
        for (int i = 0; i < 20; i++) {
            System.out.println(thread.getName() + "在插入数据" + i);
            arrayList.add(i);
        }
    }
}
```
结果：
```
Thread-0在插入数据0
Thread-0在插入数据1
Thread-0在插入数据2
Thread-0在插入数据3
Thread-0在插入数据4
Thread-0在插入数据5
Thread-0在插入数据6
Thread-0在插入数据7
Thread-0在插入数据8
Thread-0在插入数据9
...
```
从上输出结果说明，Thread-1插入数据是等Thread-0插入完数据之后才进行的。说明Thread-0和Thread-1是顺序执行insert方法的。

注意点：
1. 当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。
1. 当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。原因，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的，
1. 如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。

#### synchronized代码块
获取当前对象的锁，也可以是类中的一个属性，代表获取该属性的锁。
```java
class InsertData {
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();
    
    public void insert(Thread thread) {
        synchronized (this) {
            for(int i = 0; i < 100; i++) {
                System.out.println(thread.getName()+"在插入数据"+i);
                arrayList.add(i);
            }
        }
    }
}
```
```java
class InsertData {
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();
    private Object object = new Object();
    
    public void insert(Thread thread) {
        synchronized (object) {
            for(int i = 0; i < 100; i++) {
                System.out.println(thread.getName()+"在插入数据"+i);
                arrayList.add(i);
            }
        }
    }
}
```

<br>
每个类也会有一个锁，它可以用来控制对static数据成员的并发访问。<br>
并且如果一个线程执行一个对象的非static synchronized方法，另外一个线程需要执行这个对象所属类的static synchronized方法，此时不会发生互斥现象，因为访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁，所以不存在互斥现象。

```java
public class Test {

    public static void main(String[] args)  {
        final InsertData insertData = new InsertData();
        new Thread(() -> insertData.insert()).start(); 

        new Thread(() -> insertData.insert1()).start(); 
    }  
}

class InsertData { 
    public synchronized void insert(){
        System.out.println("执行insert");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("执行insert完毕");
    }
    
    public synchronized static void insert1() {
        System.out.println("执行insert1");
        System.out.println("执行insert1完毕");
    }
}
```
结果：
```
执行insert
执行insert1
执行insert1完毕
执行insert完毕
```

<br>
从反编译获得的字节码可以看出，synchronized代码块实际上多了**monitorenter和monitorexit**两条指令。monitorenter指令执行时会让对象的锁计数加1，而monitorexit指令执行时会让对象的锁计数减1，其实这个与操作系统里面的PV操作很像，操作系统里面的PV操作就是用来控制多个线程对临界资源的访问。

#### 释放锁的情况
1. 获取锁的线程执行完了该代码块，然后线程释放对锁的占有；
1. 线程执行发生异常，此时JVM会让线程自动释放锁。

#### 缺陷
1. 等待获取锁的线程只能等待获取锁的线程释放锁，影响程序执行效率。
例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。
但是采用synchronized关键字来实现同步的话，就会导致一个问题：
如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。



### Lock
#### Lock VS synchronized
* Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；
* Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。

#### Lock接口
```java
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
```
lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。
* lock()
    用来获取锁。如果锁已被其他线程获取，则进行等待。
    一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。
    ```java
    Lock lock = ...;
    lock.lock();
    try {
        //处理任务
    } catch(Exception ex) {
        
    } finally {
        lock.unlock();   //释放锁
    }
    ```

* tryLock()
    有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。

* tryLock(long time, TimeUnit unit)
    与tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。
    ```java
    Lock lock = ...;
    if (lock.tryLock()) {
        try {
            //处理任务
        } catch(Exception ex) {
            
        } finally {
            lock.unlock();   //释放锁
        } 
    } else {
        //如果不能获取锁，则直接做其他事情
    }
    ```

* lockInteruptibly()
    lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。
    由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。
    ```java
    public void method() throws InterruptedException {
        lock.lockInterruptibly();
        try {  
            //.....
        } finally {
            lock.unlock();
        }  
    }
    ```
    注意，**当一个线程获取了锁之后，是不会被interrupt()方法中断的。**因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。
    因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。
    而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。

#### ReentrantLock
“可重入锁”，唯一实现了Lock接口的类。
* lock()
    ```java
    public class Test {
        private ArrayList<Integer> arrayList = new ArrayList<Integer>();
        private Lock lock = new ReentrantLock();    //注意这个地方，类成员

        public static void main(String[] args) {
            final Test test = new Test();

            new Thread(() -> test.testLock(Thread.currentThread())).start();
            new Thread(() -> test.testLock(Thread.currentThread())).start();
        }

        public void testLock(Thread thread) {
            lock.lock();
            try {
                System.out.println(thread.getName() + "得到了锁");
                for (int i = 0; i < 3; i++) {
                    arrayList.add(i);
                    System.out.println(i);
                }
            } catch (Exception e) {
                // TODO: handle exception
            } finally {
                System.out.println(thread.getName() + "释放了锁");
                lock.unlock();
            }
        }
    }
    ```
    结果：
    ```java
    Thread-0得到了锁
    0
    1
    2
    Thread-0释放了锁
    Thread-1得到了锁
    0
    1
    2
    Thread-1释放了锁
    ```

* tryLock()
    ```java
    public void testTryLock(Thread thread) {
        if (lock.tryLock()) {
            try {
                System.out.println(thread.getName() + "得到了锁");
                for (int i = 0; i < 3; i++) {
                    arrayList.add(i);
                }
            } catch (Exception e) {
                // TODO: handle exception
            } finally {
                System.out.println(thread.getName() + "释放了锁");
                lock.unlock();
            }
        } else {
            System.out.println(thread.getName() + "获取锁失败");
        }
    }
    ```
    结果：
    ```
    Thread-0得到了锁
    Thread-1获取锁失败
    Thread-0释放了锁
    ```

* lockInterruptibly()
    ```java
    public class Test {
        private ArrayList<Integer> arrayList = new ArrayList<Integer>();
        private Lock lock = new ReentrantLock();    //注意这个地方

        public static void main(String[] args) {
            final Test test = new Test();

            Thread thread1 = new TestLockInterruptiblyThread(test);
            Thread thread2 = new TestLockInterruptiblyThread(test);
            thread1.start();
            thread2.start();

            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            thread2.interrupt();
        }

        public void testLockInterruptibly(Thread thread) throws InterruptedException {
            lock.lockInterruptibly();   //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出
            try {
                System.out.println(thread.getName() + "得到了锁");
                long startTime = System.currentTimeMillis();
                for (; ; ) {
                    if (System.currentTimeMillis() - startTime >= 60000)
                        break;
                    //插入数据
                }
            } finally {
                System.out.println(Thread.currentThread().getName() + "执行finally");
                lock.unlock();
                System.out.println(thread.getName() + "释放了锁");
            }
        }
    }

    class TestLockInterruptiblyThread extends Thread {
        private Test test = null;
        public TestLockInterruptiblyThread(Test test) {
            this.test = test;
        }
        @Override
        public void run() {
            try {
                test.testLockInterruptibly(Thread.currentThread());
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName()+"被中断");
            }
        }
    }
    ```
    结果：
    ```
    Thread-0得到了锁
    Thread-1被中断
    Thread-0执行finally
    Thread-0释放了锁
    ```