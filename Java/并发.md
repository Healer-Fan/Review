### 三个概念
#### 原子性
即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
* 在Java中，对**基本数据类型**的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。

#### 可见性
当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
* 提供了volatile关键字来保证可见性。

#### 有序性
程序执行的顺序按照代码的先后顺序执行。
* 指令重排序：
    一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
* Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。
* happens-befoe原则：
    * 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
    * 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
    * volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
    * 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
    * 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
    * 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
    * 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
    * 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

### synchronized [参考](http://www.cnblogs.com/dolphin0520/p/3923737.html)
如果对临界资源加上互斥锁，当一个线程在访问该临界资源时，其他线程便只能等待。
在Java中，每一个对象都拥有一个**锁标记（monitor）**，也称为监视器，多线程同时访问某个对象时，线程只有获取了该对象的锁才能访问。
在Java中，可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法或方法块，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。
#### synchronized方法
```java
public class Main {
    public static void main(String[] args) {
        final InsertData insertData = new InsertData();

        new Thread(() -> insertData.insert(Thread.currentThread())).start();

        new Thread(() -> insertData.insert(Thread.currentThread())).start();
    }
}

class InsertData {
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();
    
    public void insert(Thread thread) {
        for (int i = 0; i < 20; i++) {
            System.out.println(thread.getName() + "在插入数据" + i);
            arrayList.add(i);
        }
    }
}
```
结果：
```
Thread-0在插入数据0
Thread-0在插入数据1
Thread-0在插入数据2
Thread-0在插入数据3
Thread-1在插入数据0
Thread-0在插入数据4
Thread-1在插入数据1
Thread-0在插入数据5
Thread-1在插入数据2
...
```
说明两个线程在同时执行insert方法。

在insert方法前面加上关键字synchronized
```java
public class InsertData {

    private ArrayList<Integer> arrayList = new ArrayList<Integer>();

    public synchronized void insert(Thread thread) {
        for (int i = 0; i < 20; i++) {
            System.out.println(thread.getName() + "在插入数据" + i);
            arrayList.add(i);
        }
    }
}
```
结果：
```
Thread-0在插入数据0
Thread-0在插入数据1
Thread-0在插入数据2
Thread-0在插入数据3
Thread-0在插入数据4
Thread-0在插入数据5
Thread-0在插入数据6
Thread-0在插入数据7
Thread-0在插入数据8
Thread-0在插入数据9
...
```
从上输出结果说明，Thread-1插入数据是等Thread-0插入完数据之后才进行的。说明Thread-0和Thread-1是顺序执行insert方法的。

注意点：
1. 当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。
1. 当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。原因，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的，
1. 如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。

#### synchronized代码块
获取当前对象的锁，也可以是类中的一个属性，代表获取该属性的锁。
```java
class InsertData {
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();
    
    public void insert(Thread thread) {
        synchronized (this) {
            for(int i = 0; i < 100; i++) {
                System.out.println(thread.getName()+"在插入数据"+i);
                arrayList.add(i);
            }
        }
    }
}
```
```java
class InsertData {
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();
    private Object object = new Object();
    
    public void insert(Thread thread) {
        synchronized (object) {
            for(int i = 0; i < 100; i++) {
                System.out.println(thread.getName()+"在插入数据"+i);
                arrayList.add(i);
            }
        }
    }
}
```

<br>
每个类也会有一个锁，它可以用来控制对static数据成员的并发访问。<br>
并且如果一个线程执行一个对象的非static synchronized方法，另外一个线程需要执行这个对象所属类的static synchronized方法，此时不会发生互斥现象，因为访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁，所以不存在互斥现象。

```java
public class Test {

    public static void main(String[] args)  {
        final InsertData insertData = new InsertData();
        new Thread(() -> insertData.insert()).start(); 

        new Thread(() -> insertData.insert1()).start(); 
    }  
}

class InsertData { 
    public synchronized void insert(){
        System.out.println("执行insert");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("执行insert完毕");
    }
    
    public synchronized static void insert1() {
        System.out.println("执行insert1");
        System.out.println("执行insert1完毕");
    }
}
```
结果：
```
执行insert
执行insert1
执行insert1完毕
执行insert完毕
```

<br>
从反编译获得的字节码可以看出，synchronized代码块实际上多了**monitorenter和monitorexit**两条指令。monitorenter指令执行时会让对象的锁计数加1，而monitorexit指令执行时会让对象的锁计数减1，其实这个与操作系统里面的PV操作很像，操作系统里面的PV操作就是用来控制多个线程对临界资源的访问。

#### 释放锁的情况
1. 获取锁的线程执行完了该代码块，然后线程释放对锁的占有；
1. 线程执行发生异常，此时JVM会让线程自动释放锁。

#### 缺陷
1. 等待获取锁的线程只能等待获取锁的线程释放锁，影响程序执行效率。
例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。
但是采用synchronized关键字来实现同步的话，就会导致一个问题：
如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。



### Lock [参考](http://www.cnblogs.com/dolphin0520/p/3923167.html)
#### Lock接口
```java
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
```
lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。
* lock()
    用来获取锁。如果锁已被其他线程获取，则进行等待。
    一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。
    ```java
    Lock lock = ...;
    lock.lock();
    try {
        //处理任务
    } catch(Exception ex) {
        
    } finally {
        lock.unlock();   //释放锁
    }
    ```

* tryLock()
    有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。

* tryLock(long time, TimeUnit unit)
    与tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。
    ```java
    Lock lock = ...;
    if (lock.tryLock()) {
        try {
            //处理任务
        } catch(Exception ex) {
            
        } finally {
            lock.unlock();   //释放锁
        } 
    } else {
        //如果不能获取锁，则直接做其他事情
    }
    ```

* lockInteruptibly()
    lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。
    由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。
    ```java
    public void method() throws InterruptedException {
        lock.lockInterruptibly();
        try {  
            //.....
        } finally {
            lock.unlock();
        }  
    }
    ```
    注意，**当一个线程获取了锁之后，是不会被interrupt()方法中断的。**因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。
    因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。
    而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。

#### ReentrantLock
“可重入锁”，唯一实现了Lock接口的类。
* lock()
    ```java
    public class Test {
        private ArrayList<Integer> arrayList = new ArrayList<Integer>();
        private Lock lock = new ReentrantLock();    //注意这个地方，类成员

        public static void main(String[] args) {
            final Test test = new Test();

            new Thread(() -> test.testLock(Thread.currentThread())).start();
            new Thread(() -> test.testLock(Thread.currentThread())).start();
        }

        public void testLock(Thread thread) {
            lock.lock();
            try {
                System.out.println(thread.getName() + "得到了锁");
                for (int i = 0; i < 3; i++) {
                    arrayList.add(i);
                    System.out.println(i);
                }
            } catch (Exception e) {
                // TODO: handle exception
            } finally {
                System.out.println(thread.getName() + "释放了锁");
                lock.unlock();
            }
        }
    }
    ```
    结果：
    ```java
    Thread-0得到了锁
    0
    1
    2
    Thread-0释放了锁
    Thread-1得到了锁
    0
    1
    2
    Thread-1释放了锁
    ```

* tryLock()
    ```java
    public void testTryLock(Thread thread) {
        if (lock.tryLock()) {
            try {
                System.out.println(thread.getName() + "得到了锁");
                for (int i = 0; i < 3; i++) {
                    arrayList.add(i);
                }
            } catch (Exception e) {
                // TODO: handle exception
            } finally {
                System.out.println(thread.getName() + "释放了锁");
                lock.unlock();
            }
        } else {
            System.out.println(thread.getName() + "获取锁失败");
        }
    }
    ```
    结果：
    ```
    Thread-0得到了锁
    Thread-1获取锁失败
    Thread-0释放了锁
    ```

* lockInterruptibly()
    ```java
    public class Test {
        private ArrayList<Integer> arrayList = new ArrayList<Integer>();
        private Lock lock = new ReentrantLock();    //注意这个地方

        public static void main(String[] args) {
            final Test test = new Test();

            Thread thread1 = new TestLockInterruptiblyThread(test);
            Thread thread2 = new TestLockInterruptiblyThread(test);
            thread1.start();
            thread2.start();

            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            thread2.interrupt();
        }

        public void testLockInterruptibly(Thread thread) throws InterruptedException {
            lock.lockInterruptibly();   //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出
            try {
                System.out.println(thread.getName() + "得到了锁");
                long startTime = System.currentTimeMillis();
                for (; ; ) {
                    if (System.currentTimeMillis() - startTime >= 60000)
                        break;
                    //插入数据
                }
            } finally {
                System.out.println(Thread.currentThread().getName() + "执行finally");
                lock.unlock();
                System.out.println(thread.getName() + "释放了锁");
            }
        }
    }

    class TestLockInterruptiblyThread extends Thread {
        private Test test = null;
        public TestLockInterruptiblyThread(Test test) {
            this.test = test;
        }
        @Override
        public void run() {
            try {
                test.testLockInterruptibly(Thread.currentThread());
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName()+"被中断");
            }
        }
    }
    ```
    结果：
    ```
    Thread-0得到了锁
    Thread-1被中断
    Thread-0执行finally
    Thread-0释放了锁
    ```

#### ReadWriteLock接口
```java
public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
```

#### ReentrantReadWriteLock
```java
public class Test {
    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
     
    public static void main(String[] args)  {
        final Test test = new Test();
         
        new Thread(() -> test.get(Thread.currentThread())).start();
        new Thread(() -> test.get(Thread.currentThread())).start();
    }  
     
    public void get(Thread thread) {
        rwl.readLock().lock();
        try {
            long start = System.currentTimeMillis();
             
            while(System.currentTimeMillis() - start <= 1) {
                System.out.println(thread.getName()+"正在进行读操作");
            }
            System.out.println(thread.getName()+"读操作完毕");
        } finally {
            rwl.readLock().unlock();
        }
    }
}
```
结果：
```
Thread-0正在进行读操作
Thread-0正在进行读操作
Thread-1正在进行读操作
Thread-0正在进行读操作
Thread-1正在进行读操作
Thread-0正在进行读操作
Thread-1正在进行读操作
Thread-1正在进行读操作
Thread-1正在进行读操作
Thread-1正在进行读操作
Thread-1正在进行读操作
Thread-1正在进行读操作
Thread-0正在进行读操作
Thread-0正在进行读操作
...
```
说明thread1和thread2在同时进行读操作。
这样就大大提升了读操作的效率。
不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。
如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。

### Lock VS synchronized
1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
1. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
1. Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
1. 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
1. Lock可以提高多个线程进行读操作的效率。
1. 当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。

### 锁
#### 可重入锁
表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。
例子：当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。
```java
class MyClass {
    public synchronized void method1() {
        method2();
    }
     
    public synchronized void method2() {
         
    }
}
```
ReentrantLock 和synchronized 都是可重入锁。可重入锁最大的作用是**避免死锁**。

#### 公平锁
尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。
* synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。
* 而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。


### volatile [参考](http://www.cnblogs.com/dolphin0520/p/3920373.html)
#### 两层含义
1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
1. 禁止进行指令重排序。
#### 不能保证原子性
自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。
#### 在一定程序上保证有序性
* 禁止进行指令重排序两层含义
    1. 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
    1. 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

### ThreadLocal
提供的方法：
```java
public T get() { }
public void set(T value) { }
public void remove() { }
protected T initialValue() { }
```
get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。

#### 如何为每个线程创建一个变量的副本
1. 首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。
1. 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。
1. 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。

* 注意：
1. 实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；
2. 为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；
3. 在进行get之前，必须先set，否则会报空指针异常；

#### 适用场景
如上文所述，ThreadLocal 适用于如下两种场景
1. 每个线程需要有自己单独的实例
    每个线程拥有自己实例，实现它的方式很多。例如可以在线程内部构建一个单独的实例。ThreadLocal 可以以非常方便的形式满足该需求。
1. 实例需要在多个方法中共享，但不希望被多线程共享
    可以在满足第一点（每个线程有自己的实例）的条件下，通过方法间引用传递的形式实现。ThreadLocal 使得代码耦合度更低，且实现更优雅。

#### 总结
* ThreadLocal 并不解决线程间共享数据的问题。
* ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题。
* 每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题。
* ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题。
* ThreadLocalMap 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏。
* ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景。


### ConcurrentModificationException
#### 原因
```java
public class Test {
    public static void main(String[] args)  {
        ArrayList<Integer> list = new ArrayList<Integer>();
        list.add(2);
        Iterator<Integer> iterator = list.iterator();
        while(iterator.hasNext()){
            Integer integer = iterator.next();
            if(integer==2)
                list.remove(integer);
        }
    }
}
```
结果：
```
Exception in thread "main" java.util.ConcurrentModificationException
	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:907)
	at java.util.ArrayList$Itr.next(ArrayList.java:857)
	at Test.testConcurrentModificationException(Test.java:107)
	at Test.main(Test.java:26)
```

```java
public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index < size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index < size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}

private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                numMoved);
    elementData[--size] = null; // Let gc do its work
}
```
通过remove(Object o)方法删除元素最终是调用的fastRemove()方法，在fastRemove()方法中，首先对modCount进行加1操作（因为对集合修改了一次），然后接下来就是删除元素的操作，最后将size进行减1操作，并将引用置为null以方便垃圾收集器进行回收工作。
此时，modCount不等于expectedModCount，则抛出ConcurrentModificationException异常。
关键点就在于：**调用list.remove(Object o)方法导致modCount和expectedModCount的值不一致。**

#### 单线程解决方案
Itr类中有
```java
public void remove() {
    if (lastRet == -1)
        throw new IllegalStateException();
    checkForComodification();
 
    try {
        AbstractList.this.remove(lastRet);
    if (lastRet < cursor)
        cursor--;
    lastRet = -1;
    expectedModCount = modCount;    // 这句重要
    } catch (IndexOutOfBoundsException e) {
        throw new ConcurrentModificationException();
    }
}
```
所以，只要调用Itr类的remove()即可。

#### 多线程解决方案
```java
public class Test {
    static ArrayList<Integer> list = new ArrayList<Integer>();
    public static void main(String[] args)  {
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);
        Thread thread1 = new Thread(){
            public void run() {
                Iterator<Integer> iterator = list.iterator();
                while(iterator.hasNext()){
                    Integer integer = iterator.next();
                    System.out.println(integer);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            };
        };
        Thread thread2 = new Thread(){
            public void run() {
                Iterator<Integer> iterator = list.iterator();
                while(iterator.hasNext()){
                    Integer integer = iterator.next();
                    if(integer==2)
                        iterator.remove(); 
                }
            };
        };
        thread1.start();
        thread2.start();
    }
}
```
虽然Vector的方法采用了synchronized进行了同步，但是实际上通过Iterator访问的情况下，每个线程里面返回的是不同的iterator，也即是说expectedModCount是每个线程私有。假若此时有2个线程，线程1在进行遍历，线程2在进行修改，那么很有可能**导致线程2修改后导致Vector中的modCount自增了，线程2的expectedModCount也自增了，但是线程1的expectedModCount没有自增**，此时线程1遍历时就会出现expectedModCount不等于modCount的情况了。

解决方案：
1. 在使用iterator迭代的时候使用synchronized或者Lock进行同步；
1. 使用并发容器CopyOnWriteArrayList代替ArrayList和Vector。