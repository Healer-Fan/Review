### 1. Java程序具体执行的过程：
![](./pic/java执行过程.jpg)
首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM会用一段空间来存储**程序执行期间**需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。

### 2. 运行时数据区包括那几部分？
![](./pic/运行时数据区.png)
运行时数据区通常包括这几个部分：程序计数器(Program Counter Register)、Java栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。

### 3. 运行时数据区的每部分到底存储了哪些数据？
1. 程序计数器
    程序计数器（Program Counter Register），也有称作为PC寄存器。
    <font color="#f00">JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示 执行哪条指令的。</font>
    由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，<font color="#f00">程序计数器是每个线程所私有的。</font>
    <font color="#f00">在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。</font>
    <font color="#f00">由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。</font>

1. Java栈
    Java栈也称作虚拟机栈（Java Vitual Machine Stack）。<font color="#f00">Java栈是Java方法执行的内存模型。</font>
    Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括<font color="#f00">局部变量表、操作数栈、指向当前方法所属的类的运行时常量池的引用、方法返回地址和一些额外的附加信息。</font>
    当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便将栈帧出栈，用完就消失。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。
    栈内存中的数据，没有默认初始化值，需要手动设置。
    ![](./pic/Java栈模型.jpg)
    + 局部变量表
        用来存储<font color="#00f">方法</font>中的<font color="#f00">局部变量（包括在方法中声明的非静态变量以及函数形参）</font>。
        对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。
    + 操作数栈
        程序中的所有计算过程都是在借助于操作数栈来完成的。
    + 指向运行时常量池的引用
        因为在方法执行的过程中有可能需要用到<font color="#f00">类中的常量</font>，所以必须要有一个引用指向运行时常量。
    + 方法返回地址
        当一个方法执行完毕之后，要返回之前调用它的地方。
    
    由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。

1. 本地方法栈
    本地方法栈与Java栈的作用和原理非常相似。区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。
    <font color="#f00">在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。</font>

1. 堆
    Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。
    在Java中，程序员基本不用去关心空间释放的问题，<font color="#f00">Java的垃圾回收机制会自动进行处理</font>。因此这部分空间也是Java垃圾收集器管理的主要区域。
    <font color="#f00">堆是被所有线程共享的，在JVM中只有一个堆，随虚拟机的启动而创建。</font>

1. 方法区
    方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。
    在方法区中，存储了<font color="#f00">每个<font color="#00f">类</font>的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码</font>等。
    在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是<font color="#f00">常量池</font>，用来存储编译期间生成的字面量和符号引用。
    在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。
    不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了，移到了堆中。

1. 运行时常量池
    JDK1.6之前：运行时常量池存在于方法区
    JDK1.7之后：运行时常量池存在于堆
    **<font color="#f00">有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式。
    在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。</font>**

### 逃逸分析
* 逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其它变量引用。正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；故由于无法回收，即成为逃逸。
* 逃逸分析可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配，由于该对象一定是局部的，所以栈上分配不会有问题。

### TLAB
* JVM在内存新生代Eden Space中开辟了一小块线程私有的区域TLAB（Thread-local allocation buffer），即线程本地分配缓存区。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。
* 也就是说，Java中每个线程都会有自己的缓冲区称作TLAB，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。